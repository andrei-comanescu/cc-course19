from __future__ import division, print_function

import os
import shutil
import argparse
import numpy as np
import tensorflow as tf
from .style_help.utils import preserve_colors_np
from .style_help.utils import get_files, get_img, get_img_crop, save_img, resize_to, center_crop
import scipy
import time
from .style_help.wct import WCT


#GLOBAL VARS
CHECKPOINTS = ['style_help/models/relu5_1', 'style_help/models/relu4_1', 'style_help/models/relu3_1', 'style_help/models/relu2_1', 'style_help/models/relu1_1']
                                                #List of checkpoint directories 
RELU_TARGETS = ['relu5_1', 'relu4_1', 'relu3_1', 'relu2_1', 'relu1_1']                                 
                                                #List of reluX_1 layers, corresponding to --checkpoints
VGG_PATH = 'style_help/models/vgg_normalised.t7' #Path to vgg_normalised.t7
CONTENT_PATH = '../images/content'              #Content image or folder of images
STYLE_PATH = '../images/style'                  #Style image or folder of images
OUT_PATH = '../images/output'                   #Output folder path
KEEP_COLORS = False                             #Preserve the colors of the style image
DEVICE = '/cpu:0'                               #Device to perform compute on, e.g. /gpu:0 I only have one GPU so loading this one in cpu.
STYLE_SIZE = 0                                  #Resize style image to this size before cropping, default 512
CROP_SIZE = 0                                   #Crop square size, default 256
CONTENT_SIZE = 0                                #Resize short side of content image to this
PASSES = 1                                      # of stylization passes per content image
ALPHA = 1                                       #Alpha blend value
CONCAT = False                                  #Concatenate style image and stylized output
ADAIN = False                                   #Use AdaIN instead of WCT
SWAP5 = False                                   #Swap style on layer relu5_1
SS_ALPHA = 0.6                                  #Style swap alpha blend
SS_PATH_SIZE = 3                                #Style swap patch size
SS_STRIDE = 1                                   #Style swap stride
PATH = os.path.dirname(os.path.realpath(__file__))

print (f'Loading StyleTransfer module on {DEVICE}.........')
 # Load the WCT model
   
checkpoints = []
for i in CHECKPOINTS:
    i = os.path.join(PATH,i)
    checkpoints.append(i)

wct_model = WCT(checkpoints=checkpoints, 
                                relu_targets=RELU_TARGETS,
                                vgg_path=os.path.join(PATH, VGG_PATH), 
                                device=DEVICE,
                                ss_patch_size=SS_PATH_SIZE, 
                                ss_stride=SS_STRIDE)

print ('StyleTransfer module loaded!')


def stylize(alpha=ALPHA, content_path=CONTENT_PATH, style_path=STYLE_PATH, style_size=STYLE_SIZE,
             crop_size=CROP_SIZE, keep_colors=KEEP_COLORS, passes=PASSES,swap5=SWAP5, concat=CONCAT):
    start = time.time() 
    # Get content & style full paths
    content_path = os.path.join(PATH, content_path)
    style_path = os.path.join(PATH, style_path)
    if os.path.isdir(content_path):
        content_files = get_files(content_path)
    if os.path.isdir(style_path):
        style_files = get_files(style_path)
    out_path =  os.path.join(PATH, OUT_PATH)
    os.makedirs(out_path, exist_ok=True)

    count = 0
    out_files = []
    ### Apply style to content images generated for given word pairs and emotion
    for content_file in content_files:
        content_prefix, content_ext = os.path.splitext(content_file)
        content_prefix = os.path.basename(content_prefix)  # Extract filename prefix without ext
        #apply style transfer to only content images that have been generated by current input
        if int(content_prefix[-1]) == 1:
            continue    
        content_img = get_img(content_file)
        if CONTENT_SIZE > 0:
            content_img = resize_to(content_img, CONTENT_SIZE)
            
        for style_file in style_files:
            style_prefix, _ = os.path.splitext(style_file)
            style_prefix = os.path.basename(style_prefix)  # Extract filename prefix without ext
            if int(style_prefix[-1]) == 1:
                continue 
            style_img = get_img(style_file)

            if style_size > 0:
                style_img = resize_to(style_img, style_size)
            if crop_size > 0:
                style_img = center_crop(style_img, crop_size)
            if keep_colors:
                style_img = preserve_colors_np(style_img, content_img)
            # Run the frame through the style network
            stylized_rgb = wct_model.predict(content_img, style_img, alpha, swap5, SS_ALPHA, ADAIN)
            if passes > 1:
                for _ in range(passes-1):
                    stylized_rgb = wct_model.predict(stylized_rgb, style_img, alpha, swap5, SS_ALPHA, ADAIN)

            # Stitch the style + stylized output together, but only if there's one style image
            if concat:
                # Resize style img to same height as frame
                style_img_resized = scipy.misc.imresize(style_img, (stylized_rgb.shape[0], stylized_rgb.shape[0]))
                stylized_rgb = np.hstack([style_img_resized, stylized_rgb])

            # Format for out filename: {out_path}/{content_prefix}_{style_prefix}.{content_ext}
            out_f = os.path.join(out_path, '{}_{}{}'.format(content_prefix, style_prefix, content_ext))
            # out_f = f'{content_prefix}_{style_prefix}.{content_ext}'
            out_files.append(out_f)
            save_img(out_f, stylized_rgb)
            count += 1
            print("{}: Wrote stylized output image to {}".format(count, out_f))
            shutil.move(os.path.join(PATH,style_file),os.path.join(PATH,'../images/style/'+style_prefix+'_1'+content_ext)) 
        shutil.move(os.path.join(PATH,content_file),os.path.join(PATH,'../images/content/'+content_prefix+'_1'+content_ext)) 
    print("Finished stylizing {} outputs in {}s".format(count, time.time() - start))
    if len(out_files) > 0:
        return out_files

